# Weekly Report (20 – 27 Oct 2025)

## Day-by-Day Progress

### Monday, Oct 20
Started the week with an **introduction to serialization in Nervos CKB**.  
* Learned that serialization converts data structures into binary formats for storage, transmission, and reconstruction.  
* Noted the three core requirements for CKB serialization: **stability**, **consistency**, and **efficiency**.  
* Identified the two formats used in the ecosystem: **JSON** (RPC-facing) and **Molecule** (core on-chain format).

### Tuesday, Oct 21
Dove deeper into **why Molecule is used in CKB**.  
* Compared Molecule with alternatives (Protocol Buffers / FlatBuffers) and observed cross-language byte representation issues in those formats.  
* Understood CKB-specific needs: **canonicalization**, **partial reading**, and **version compatibility**.  
* Documented Molecule’s three main advantages:
  * **Canonicalization** — identical byte results across implementations.  
  * **Partial reading & self-contained substructures** — extract substructures without parsing the whole parent.  
  * **Zero-copy** — parse/access memory locations directly for performance.

### Wednesday, Oct 22
Studied **Molecule Rust library features and versioning**.  
* Noted that the Molecule reference implementation is written in **Rust**.  
* Default Rust features include `std::*`, `faster-hex`, and `bytes_vec` (for backward compatibility).  
* Benchmarks are commonly run using **serde** in Rust environments.  
* Confirmed **minimum supported Rust version: 1.56.1** (Molecule may not build on earlier Rust versions).  
* Learned how to configure Molecule for **no-std** usage in CKB scripts:

```toml
# for no-std CKB scripts (Molecule <= 0.7)
molecule = { version = "0.7", default-features = false }

# for Molecule >= 0.8 (bytes_vec required)
molecule = { version = "0.8.0", default-features = false, features = ["bytes_vec"] }
```

### Thursday, Oct 23
Installed and tried Molecule tooling (schema compiler / codegen).  
* Installed `moleculec` via Cargo:

```bash
cargo install moleculec --locked
```
* Practiced generating code with:

```bash
moleculec --language <language> --schema-file <schema-file>
```
* Noted the official generator supports Rust and C; community implementations exist for Go, JS/TS (`moleculec-es`, `moleculec-go`), etc.  
* Looked at editor plugins (Emacs, Vim, Sublime) to improve schema authoring.

### Friday, Oct 24
Studied **Molecule Schema Language** (types, grammar, memory layout).  
* Learned primitive: `byte`.  
* Reviewed composite types: array, struct, vector (fixvec / dynvec), table, option, union.  
* Studied memory layout patterns and headers (all header integers are 32-bit little-endian).  
* Practiced encoding rules and how fixed-size vs dynamic-size types are serialized.

### Saturday, Oct 25
Worked through **encoding examples and edge cases**.  
* Serialized arrays and structs (no overhead for fixed-size types).  
* Practiced fixvec vs dynvec encoding (length vs full-size + offsets).  
* Walked through table, option, and union examples, noting how offsets and type IDs are represented.  
* Verified that Molecule requires explicit packing/unpacking for byte sequences and that developers must handle ordering/limits manually when needed.

### Sunday, Oct 26
Implemented and reviewed a **complete example (Role-Playing Game)** using multiple schema files.  
* Example comprised: Basic Types, Attributes, Roles, Skills.  
* Observed how Molecule expresses typed aliases (e.g., `AttrValue` as `array AttrValue [byte; 1]`) to provide compile-time guarantees and clearer intent.  
* Reviewed table usage for Hero and Monster, and union/option usage for skills.  
* Noted how this example demonstrates nested structures and dynamic lists for real-world schema design.

### Monday, Oct 27
Explored **CCC Molecule (JavaScript/TypeScript) integration and advanced codec patterns**.  
* Used CCC SDK mol utilities to encode/decode basic and composite Molecule types:

```js
import { mol } from "@ckb-ccc/core";
ccc.mol.Bytes.encode("0x123456");
ccc.mol.struct({ a: ccc.mol.Byte4, b: ccc.mol.Byte4 }).encode({ ... });
```
* Explored CCC built-in types and helpers (`Bool`, `Byte16`, `Byte32`, `Uint8`, `Uint128LE`, etc.).  
* Implemented custom codec bindings (example: `AttrValueCodec`) that include validation (upper limit checks) before serialization.  
* Tried `@mol.codec` decorator and class-based entities (e.g., `Monster` derived from `mol.Entity.Base`) to simplify object ↔ Molecule conversions.

---

## Summary of the Week
This week was a focused deep dive into **Molecule — the canonical serialization format for Nervos CKB**.  
* Covered conceptual motivations (consistency, partial reads, zero-copy performance).  
* Hands-on with the Rust reference library, toolchain (`moleculec`), schema language, and encoding rules.  
* Built and validated a multi-file schema example (RPG) to understand nested structures and dynamic collections.  
* Integrated Molecule usage into dApp workflows using the CCC JavaScript/TypeScript SDK and demonstrated how to write robust codec bindings with validation.

##  Challenges & Notes
* Molecule’s binary layout is precise — small mistakes in offsets or endianness break decoding.  
* Need to be explicit about packing/unpacking byte sequences; Molecule does not implicitly manage ordering or higher-level invariants.  
* Cross-language support depends on community implementations; official generator focuses on Rust/C.  
* When using Molecule in no-std CKB scripts, ensure dependencies and features (e.g., `bytes_vec`) are configured correctly for the target runtime.

## Goals for Next Week
* Generate Rust and JS bindings from the RPG schema using `moleculec` and test round-trip serialization.  
* Implement more complex union/option test cases and edge-case fuzzing to validate decoder robustness.  
* Add automated validation in CCC codec bindings (e.g., enforce `AttrValue` range) and unit tests.  
* Prototype a small CKB script that reads a Molecule table partially (verify partial-read semantics).

---


